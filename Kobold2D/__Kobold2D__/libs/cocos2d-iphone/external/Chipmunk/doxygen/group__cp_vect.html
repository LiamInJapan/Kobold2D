<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Chipmunk-Physics: cpVect</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>cpVect</h1>  </div>
</div>
<div class="contents">

<p>Chipmunk's 2D vector type along with a handy 2D vector math lib.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80c0be464748ff46ad20b58e22ea7d81"></a><!-- doxytag: member="cpVect::cpv" ref="ga80c0be464748ff46ad20b58e22ea7d81" args="(const cpFloat x, const cpFloat y)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga80c0be464748ff46ad20b58e22ea7d81">cpv</a> (const cpFloat x, const cpFloat y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience constructor for <a class="el" href="structcp_vect.html">cpVect</a> structs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga77014268325c2b7c93ee59f64cd78a5c"></a><!-- doxytag: member="cpVect::cpvlength" ref="ga77014268325c2b7c93ee59f64cd78a5c" args="(const cpVect v)" -->
cpFloat&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga77014268325c2b7c93ee59f64cd78a5c">cpvlength</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the length of v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad894c8a975c4afb57f1ca45907417754"></a><!-- doxytag: member="cpVect::cpvslerp" ref="gad894c8a975c4afb57f1ca45907417754" args="(const cpVect v1, const cpVect v2, const cpFloat t)" -->
<a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gad894c8a975c4afb57f1ca45907417754">cpvslerp</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2, const cpFloat t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spherical linearly interpolate between v1 and v2. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03d3b2cc67829761ed03a33d203000d9"></a><!-- doxytag: member="cpVect::cpvslerpconst" ref="ga03d3b2cc67829761ed03a33d203000d9" args="(const cpVect v1, const cpVect v2, const cpFloat a)" -->
<a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga03d3b2cc67829761ed03a33d203000d9">cpvslerpconst</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2, const cpFloat a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spherical linearly interpolate between v1 towards v2 by no more than angle a radians. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga554792bf6678c80b2606720e6f977101"></a><!-- doxytag: member="cpVect::cpvforangle" ref="ga554792bf6678c80b2606720e6f977101" args="(const cpFloat a)" -->
<a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga554792bf6678c80b2606720e6f977101">cpvforangle</a> (const cpFloat a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the unit length vector for the given angle (in radians). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga283b3cb38342bffe145247aec08a242b"></a><!-- doxytag: member="cpVect::cpvtoangle" ref="ga283b3cb38342bffe145247aec08a242b" args="(const cpVect v)" -->
cpFloat&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga283b3cb38342bffe145247aec08a242b">cpvtoangle</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the angular direction v is pointing in (in radians). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga37480a0e70b8ae9e1ea74e6483555305">cpvstr</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a string representation of v.  <a href="#ga37480a0e70b8ae9e1ea74e6483555305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5081f933bcc2c64c76d7e7caaf2d631"></a><!-- doxytag: member="cpVect::cpveql" ref="gae5081f933bcc2c64c76d7e7caaf2d631" args="(const cpVect v1, const cpVect v2)" -->
static <a class="el" href="group__basic_types.html#gab6e5d8afee598a57cd323abae5310244">cpBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gae5081f933bcc2c64c76d7e7caaf2d631">cpveql</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if two vectors are equal. (Be careful when comparing floating point numbers!). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga167e0bde13a745299bd5d4164d7c796b"></a><!-- doxytag: member="cpVect::cpvadd" ref="ga167e0bde13a745299bd5d4164d7c796b" args="(const cpVect v1, const cpVect v2)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga167e0bde13a745299bd5d4164d7c796b">cpvadd</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add two vectors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd88a5bbd4b5de25aa31e44fdf01e259"></a><!-- doxytag: member="cpVect::cpvsub" ref="gafd88a5bbd4b5de25aa31e44fdf01e259" args="(const cpVect v1, const cpVect v2)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gafd88a5bbd4b5de25aa31e44fdf01e259">cpvsub</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract two vectors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab79a1d52de40bf0f7db5134da436426b"></a><!-- doxytag: member="cpVect::cpvneg" ref="gab79a1d52de40bf0f7db5134da436426b" args="(const cpVect v)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gab79a1d52de40bf0f7db5134da436426b">cpvneg</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate a vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga717188d925550baf62188b5e1e602047"></a><!-- doxytag: member="cpVect::cpvmult" ref="ga717188d925550baf62188b5e1e602047" args="(const cpVect v, const cpFloat s)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga717188d925550baf62188b5e1e602047">cpvmult</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v, const cpFloat s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar multiplication. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e76653b018d47f864c339092cf482f1"></a><!-- doxytag: member="cpVect::cpvdot" ref="ga3e76653b018d47f864c339092cf482f1" args="(const cpVect v1, const cpVect v2)" -->
static cpFloat&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga3e76653b018d47f864c339092cf482f1">cpvdot</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector dot product. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static cpFloat&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gaf9618b7690ad0c67dbe143c640590f7b">cpvcross</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2D vector cross product analog.  <a href="#gaf9618b7690ad0c67dbe143c640590f7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4a0ba2873900342126c0449918764bc"></a><!-- doxytag: member="cpVect::cpvperp" ref="gac4a0ba2873900342126c0449918764bc" args="(const cpVect v)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gac4a0ba2873900342126c0449918764bc">cpvperp</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a perpendicular vector. (90 degree rotation). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0be2829df5c1be940484fb64b7cab61e"></a><!-- doxytag: member="cpVect::cpvrperp" ref="ga0be2829df5c1be940484fb64b7cab61e" args="(const cpVect v)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga0be2829df5c1be940484fb64b7cab61e">cpvrperp</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a perpendicular vector. (-90 degree rotation). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9c42ec78caa7971459d10543b1549cd"></a><!-- doxytag: member="cpVect::cpvproject" ref="gae9c42ec78caa7971459d10543b1549cd" args="(const cpVect v1, const cpVect v2)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gae9c42ec78caa7971459d10543b1549cd">cpvproject</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the vector projection of v1 onto v2. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac9a0bb9221f9f2068a48985fa70b5226"></a><!-- doxytag: member="cpVect::cpvrotate" ref="gac9a0bb9221f9f2068a48985fa70b5226" args="(const cpVect v1, const cpVect v2)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gac9a0bb9221f9f2068a48985fa70b5226">cpvrotate</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses complex number multiplication to rotate v1 by v2. Scaling will occur if v1 is not a unit vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2b1120be08ee9225eadede83f5e054b"></a><!-- doxytag: member="cpVect::cpvunrotate" ref="gac2b1120be08ee9225eadede83f5e054b" args="(const cpVect v1, const cpVect v2)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gac2b1120be08ee9225eadede83f5e054b">cpvunrotate</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse of <a class="el" href="group__cp_vect.html#gac9a0bb9221f9f2068a48985fa70b5226" title="Uses complex number multiplication to rotate v1 by v2. Scaling will occur if v1 is not a unit vector...">cpvrotate()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadfad8e091ac399cdc377a9c475f7ef0d"></a><!-- doxytag: member="cpVect::cpvlengthsq" ref="gadfad8e091ac399cdc377a9c475f7ef0d" args="(const cpVect v)" -->
static cpFloat&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gadfad8e091ac399cdc377a9c475f7ef0d">cpvlengthsq</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the squared length of v. Faster than <a class="el" href="group__cp_vect.html#ga77014268325c2b7c93ee59f64cd78a5c" title="Returns the length of v.">cpvlength()</a> when you only need to compare lengths. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab93f4924f5369c10782de6dba5ef38da"></a><!-- doxytag: member="cpVect::cpvlerp" ref="gab93f4924f5369c10782de6dba5ef38da" args="(const cpVect v1, const cpVect v2, const cpFloat t)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gab93f4924f5369c10782de6dba5ef38da">cpvlerp</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2, const cpFloat t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linearly interpolate between v1 and v2. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0fd46c6ef6dcca0dc7b6c6cef8008758"></a><!-- doxytag: member="cpVect::cpvnormalize" ref="ga0fd46c6ef6dcca0dc7b6c6cef8008758" args="(const cpVect v)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga0fd46c6ef6dcca0dc7b6c6cef8008758">cpvnormalize</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a normalized copy of v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae2567a9766419f4b9021b4917a4d6fa3"></a><!-- doxytag: member="cpVect::cpvnormalize_safe" ref="gae2567a9766419f4b9021b4917a4d6fa3" args="(const cpVect v)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gae2567a9766419f4b9021b4917a4d6fa3">cpvnormalize_safe</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a normalized copy of v or cpvzero if v was already cpvzero. Protects against divide by zero errors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga21bac66ee11661debe4d1ddfb710f5f8"></a><!-- doxytag: member="cpVect::cpvclamp" ref="ga21bac66ee11661debe4d1ddfb710f5f8" args="(const cpVect v, const cpFloat len)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga21bac66ee11661debe4d1ddfb710f5f8">cpvclamp</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v, const cpFloat len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clamp v to length len. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf91d2bdafb741a35ab2dc6300d9fa81"></a><!-- doxytag: member="cpVect::cpvlerpconst" ref="gaaf91d2bdafb741a35ab2dc6300d9fa81" args="(cpVect v1, cpVect v2, cpFloat d)" -->
static <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gaaf91d2bdafb741a35ab2dc6300d9fa81">cpvlerpconst</a> (<a class="el" href="structcp_vect.html">cpVect</a> v1, <a class="el" href="structcp_vect.html">cpVect</a> v2, cpFloat d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linearly interpolate between v1 towards v2 by distance d. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07488fb10c3ffb842b78ae66a2d90c00"></a><!-- doxytag: member="cpVect::cpvdist" ref="ga07488fb10c3ffb842b78ae66a2d90c00" args="(const cpVect v1, const cpVect v2)" -->
static cpFloat&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga07488fb10c3ffb842b78ae66a2d90c00">cpvdist</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the distance between v1 and v2. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb0ce5353909318beb7ee3163f7c3152"></a><!-- doxytag: member="cpVect::cpvdistsq" ref="gadb0ce5353909318beb7ee3163f7c3152" args="(const cpVect v1, const cpVect v2)" -->
static cpFloat&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#gadb0ce5353909318beb7ee3163f7c3152">cpvdistsq</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the squared distance between v1 and v2. Faster than <a class="el" href="group__cp_vect.html#ga07488fb10c3ffb842b78ae66a2d90c00" title="Returns the distance between v1 and v2.">cpvdist()</a> when you only need to compare distances. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ffc18e3b7405c28e92b6aa0f6cad746"></a><!-- doxytag: member="cpVect::cpvnear" ref="ga2ffc18e3b7405c28e92b6aa0f6cad746" args="(const cpVect v1, const cpVect v2, const cpFloat dist)" -->
static <a class="el" href="group__basic_types.html#gab6e5d8afee598a57cd323abae5310244">cpBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga2ffc18e3b7405c28e92b6aa0f6cad746">cpvnear</a> (const <a class="el" href="structcp_vect.html">cpVect</a> v1, const <a class="el" href="structcp_vect.html">cpVect</a> v2, const cpFloat dist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the distance between v1 and v2 is less than dist. <br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga18f97c9678bcb262ce182f336dad2318"></a><!-- doxytag: member="cpVect::cpvzero" ref="ga18f97c9678bcb262ce182f336dad2318" args="" -->
static const <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cp_vect.html#ga18f97c9678bcb262ce182f336dad2318">cpvzero</a> = {0.0f,0.0f}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant for the zero vector. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Chipmunk's 2D vector type along with a handy 2D vector math lib. </p>
<p>Chipmunk's 2D vector type. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf9618b7690ad0c67dbe143c640590f7b"></a><!-- doxytag: member="cpVect.h::cpvcross" ref="gaf9618b7690ad0c67dbe143c640590f7b" args="(const cpVect v1, const cpVect v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static cpFloat cpvcross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>2D vector cross product analog. </p>
<p>The cross product of 2D vectors results in a 3D vector with only a z component. This function returns the magnitude of the z value. </p>

<p>Definition at line <a class="el" href="cp_vect_8h_source.html#l00095">95</a> of file <a class="el" href="cp_vect_8h_source.html">cpVect.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga37480a0e70b8ae9e1ea74e6483555305"></a><!-- doxytag: member="cpVect.h::cpvstr" ref="ga37480a0e70b8ae9e1ea74e6483555305" args="(const cpVect v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cpvstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcp_vect.html">cpVect</a>&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a string representation of v. </p>
<p>Intended mostly for debugging purposes and not production use. </p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The string points to a static local and is reset every time the function is called. If you want to print more than one vector you will have to split up your printing onto separate lines. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Sep 20 2011 23:17:15 for Chipmunk-Physics by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
